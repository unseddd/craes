#![no_std]

/// Shitty, non-optimized (hopefully correct) AES implementation
///
/// DO NOT USE THIS LIBRARY FOR REAL SHIT, OR THE WORST THINGS WILL HAPPEN
///
/// - Sia will read your private messages
/// - Phoebe will compromise your eBay purchase
/// - Ensa will listen to your encrypted phone call
///
/// Seriously though, I have done my best to follow the [FIPS-197](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf) specification,
/// but the library has not been tested for side-channel resistance, or other cryptanalytic attacks.
///
/// I coded this AES implementation to learn more about how AES actually works.

/// Number of bits in AES-128
pub const N_128: usize = 128;

/// Number of 32-bit words per block in AES-128
pub const N_BLOCK: usize = 4;

/// Number of 32-bit words per key block in AES-128
pub const N_KEY_128: usize = 4;

/// Number of rounds in AES-128
pub const N_ROUND_128: usize = 10;

/// Number of rounds in AES-192
pub const N_ROUND_192: usize = 12;

/// Number of rounds in AES-256
pub const N_ROUND_256: usize = 14;

/// Number of 32-bit words per expanded key in AES-128
pub const N_EXPW_128: usize = 44; /* Nb * (Nr + 1) */

/// Block length (in bytes) for AES-{128,192,256}
pub const BLOCK_LEN: usize = 16;

/// Key length (in bytes) for AES-128
pub const KEY_LEN_128: usize = 16;

/// AES-128 cipher over a single block
///
/// @param msg: Message block to be encrypted
/// @param key: Key for encrypting the message
pub fn aes_128(msg: &[u8; BLOCK_LEN], key: &[u8; KEY_LEN_128]) -> [u8; BLOCK_LEN] {
    aes_inner_128(msg, expand_key_128(key))
}

fn aes_inner_128(msg: &[u8; BLOCK_LEN], w: [u32; N_EXPW_128]) -> [u8; BLOCK_LEN] {
    let mut state: [u32; 4] = [
        u32::from_be_bytes([msg[0], msg[1], msg[2], msg[3]]),
        u32::from_be_bytes([msg[4], msg[5], msg[6], msg[7]]),
        u32::from_be_bytes([msg[8], msg[9], msg[10], msg[11]]),
        u32::from_be_bytes([msg[12], msg[13], msg[14], msg[15]]),
    ];

    add_round_key(&mut state, &w[..N_BLOCK]);

    for i in 1..N_ROUND_128 {
        sub_bytes(&mut state);
        shift_rows(&mut state);
        mix_columns(&mut state);
        add_round_key(&mut state, &w[i*N_BLOCK..(i + 1) * N_BLOCK]);
    }

    sub_bytes(&mut state);
    shift_rows(&mut state);
    add_round_key(&mut state, &w[N_ROUND_128 * N_BLOCK..(N_ROUND_128 + 1) * N_BLOCK]);

    let mut out = [0u8; BLOCK_LEN];

    for (i, word) in state.iter().enumerate() {
        for (si, &byte) in word.to_be_bytes().iter().enumerate() {
            out[i*N_BLOCK + si] = byte;
        }
    }

    out
}

/// AES-128 inverse cipher over a single block
///
/// @param msg: Message block to be encrypted
/// @param key: Key for encrypting the message
pub fn aes_inv_128(cipher: &[u8; BLOCK_LEN],  key: &[u8; KEY_LEN_128]) -> [u8; BLOCK_LEN] {
    aes_inv_inner_128(cipher, expand_key_128(key))
}

fn aes_inv_inner_128(msg: &[u8; BLOCK_LEN], w: [u32; N_EXPW_128]) -> [u8; BLOCK_LEN] {
    let mut state: [u32; 4] = [
        u32::from_be_bytes([msg[0], msg[1], msg[2], msg[3]]),
        u32::from_be_bytes([msg[4], msg[5], msg[6], msg[7]]),
        u32::from_be_bytes([msg[8], msg[9], msg[10], msg[11]]),
        u32::from_be_bytes([msg[12], msg[13], msg[14], msg[15]]),
    ];

    add_round_key(&mut state, &w[N_ROUND_128 * N_BLOCK..(N_ROUND_128 + 1) * N_BLOCK]);

    for i in 1..N_ROUND_128 {
        inv_shift_rows(&mut state);
        inv_sub_bytes(&mut state);
        add_round_key(&mut state, &w[(N_ROUND_128 - i)*N_BLOCK..(N_ROUND_128 - i + 1) * N_BLOCK]);
        inv_mix_columns(&mut state);
    }

    inv_shift_rows(&mut state);
    inv_sub_bytes(&mut state);

    add_round_key(&mut state, &w[..N_BLOCK]);

    let mut out = [0u8; BLOCK_LEN];

    for (i, word) in state.iter().enumerate() {
        for (si, &byte) in word.to_be_bytes().iter().enumerate() {
            out[i*N_BLOCK + si] = byte;
        }
    }

    out
}

/// Substitution box
fn sbox(byte: u8) -> u8 {
    match byte {
        // row 0
        0x00 => 0x63, 0x01 => 0x7c, 0x02 => 0x77, 0x03 => 0x7b, 0x04 => 0xf2, 0x05 => 0x6b, 0x06 => 0x6f, 0x07 => 0xc5,
        0x08 => 0x30, 0x09 => 0x01, 0x0a => 0x67, 0x0b => 0x2b, 0x0c => 0xfe, 0x0d => 0xd7, 0x0e => 0xab, 0x0f => 0x76,
        // row 1
        0x10 => 0xca, 0x11 => 0x82, 0x12 => 0xc9, 0x13 => 0x7d, 0x14 => 0xfa, 0x15 => 0x59, 0x16 => 0x47, 0x17 => 0xf0,
        0x18 => 0xad, 0x19 => 0xd4, 0x1a => 0xa2, 0x1b => 0xaf, 0x1c => 0x9c, 0x1d => 0xa4, 0x1e => 0x72, 0x1f => 0xc0,
        // row 2
        0x20 => 0xb7, 0x21 => 0xfd, 0x22 => 0x93, 0x23 => 0x26, 0x24 => 0x36, 0x25 => 0x3f, 0x26 => 0xf7, 0x27 => 0xcc,
        0x28 => 0x34, 0x29 => 0xa5, 0x2a => 0xe5, 0x2b => 0xf1, 0x2c => 0x71, 0x2d => 0xd8, 0x2e => 0x31, 0x2f => 0x15,
        // row 3
        0x30 => 0x04, 0x31 => 0xc7, 0x32 => 0x23, 0x33 => 0xc3, 0x34 => 0x18, 0x35 => 0x96, 0x36 => 0x05, 0x37 => 0x9a,
        0x38 => 0x07, 0x39 => 0x12, 0x3a => 0x80, 0x3b => 0xe2, 0x3c => 0xeb, 0x3d => 0x27, 0x3e => 0xb2, 0x3f => 0x75,
        // row 4
        0x40 => 0x09, 0x41 => 0x83, 0x42 => 0x2c, 0x43 => 0x1a, 0x44 => 0x1b, 0x45 => 0x6e, 0x46 => 0x5a, 0x47 => 0xa0,
        0x48 => 0x52, 0x49 => 0x3b, 0x4a => 0xd6, 0x4b => 0xb3, 0x4c => 0x29, 0x4d => 0xe3, 0x4e => 0x2f, 0x4f => 0x84,
        // row 5
        0x50 => 0x53, 0x51 => 0xd1, 0x52 => 0x00, 0x53 => 0xed, 0x54 => 0x20, 0x55 => 0xfc, 0x56 => 0xb1, 0x57 => 0x5b,
        0x58 => 0x6a, 0x59 => 0xcb, 0x5a => 0xbe, 0x5b => 0x39, 0x5c => 0x4a, 0x5d => 0x4c, 0x5e => 0x58, 0x5f => 0xcf,
        // row 6
        0x60 => 0xd0, 0x61 => 0xef, 0x62 => 0xaa, 0x63 => 0xfb, 0x64 => 0x43, 0x65 => 0x4d, 0x66 => 0x33, 0x67 => 0x85,
        0x68 => 0x45, 0x69 => 0xf9, 0x6a => 0x02, 0x6b => 0x7f, 0x6c => 0x50, 0x6d => 0x3c, 0x6e => 0x9f, 0x6f => 0xa8,
        // row 7
        0x70 => 0x51, 0x71 => 0xa3, 0x72 => 0x40, 0x73 => 0x8f, 0x74 => 0x92, 0x75 => 0x9d, 0x76 => 0x38, 0x77 => 0xf5,
        0x78 => 0xbc, 0x79 => 0xb6, 0x7a => 0xda, 0x7b => 0x21, 0x7c => 0x10, 0x7d => 0xff, 0x7e => 0xf3, 0x7f => 0xd2,
        // row 8
        0x80 => 0xcd, 0x81 => 0x0c, 0x82 => 0x13, 0x83 => 0xec, 0x84 => 0x5f, 0x85 => 0x97, 0x86 => 0x44, 0x87 => 0x17,
        0x88 => 0xc4, 0x89 => 0xa7, 0x8a => 0x7e, 0x8b => 0x3d, 0x8c => 0x64, 0x8d => 0x5d, 0x8e => 0x19, 0x8f => 0x73,
        // row 9
        0x90 => 0x60, 0x91 => 0x81, 0x92 => 0x4f, 0x93 => 0xdc, 0x94 => 0x22, 0x95 => 0x2a, 0x96 => 0x90, 0x97 => 0x88,
        0x98 => 0x46, 0x99 => 0xee, 0x9a => 0xb8, 0x9b => 0x14, 0x9c => 0xde, 0x9d => 0x5e, 0x9e => 0x0b, 0x9f => 0xdb,
        // row a
        0xa0 => 0xe0, 0xa1 => 0x32, 0xa2 => 0x3a, 0xa3 => 0x0a, 0xa4 => 0x49, 0xa5 => 0x06, 0xa6 => 0x24, 0xa7 => 0x5c,
        0xa8 => 0xc2, 0xa9 => 0xd3, 0xaa => 0xac, 0xab => 0x62, 0xac => 0x91, 0xad => 0x95, 0xae => 0xe4, 0xaf => 0x79,
        // row b
        0xb0 => 0xe7, 0xb1 => 0xc8, 0xb2 => 0x37, 0xb3 => 0x6d, 0xb4 => 0x8d, 0xb5 => 0xd5, 0xb6 => 0x4e, 0xb7 => 0xa9,
        0xb8 => 0x6c, 0xb9 => 0x56, 0xba => 0xf4, 0xbb => 0xea, 0xbc => 0x65, 0xbd => 0x7a, 0xbe => 0xae, 0xbf => 0x08,
        // row c
        0xc0 => 0xba, 0xc1 => 0x78, 0xc2 => 0x25, 0xc3 => 0x2e, 0xc4 => 0x1c, 0xc5 => 0xa6, 0xc6 => 0xb4, 0xc7 => 0xc6,
        0xc8 => 0xe8, 0xc9 => 0xdd, 0xca => 0x74, 0xcb => 0x1f, 0xcc => 0x4b, 0xcd => 0xbd, 0xce => 0x8b, 0xcf => 0x8a,
        // row d
        0xd0 => 0x70, 0xd1 => 0x3e, 0xd2 => 0xb5, 0xd3 => 0x66, 0xd4 => 0x48, 0xd5 => 0x03, 0xd6 => 0xf6, 0xd7 => 0x0e,
        0xd8 => 0x61, 0xd9 => 0x35, 0xda => 0x57, 0xdb => 0xb9, 0xdc => 0x86, 0xdd => 0xc1, 0xde => 0x1d, 0xdf => 0x9e,
        // row e
        0xe0 => 0xe1, 0xe1 => 0xf8, 0xe2 => 0x98, 0xe3 => 0x11, 0xe4 => 0x69, 0xe5 => 0xd9, 0xe6 => 0x8e, 0xe7 => 0x94,
        0xe8 => 0x9b, 0xe9 => 0x1e, 0xea => 0x87, 0xeb => 0xe9, 0xec => 0xce, 0xed => 0x55, 0xee => 0x28, 0xef => 0xdf,
        // row f
        0xf0 => 0x8c, 0xf1 => 0xa1, 0xf2 => 0x89, 0xf3 => 0x0d, 0xf4 => 0xbf, 0xf5 => 0xe6, 0xf6 => 0x42, 0xf7 => 0x68,
        0xf8 => 0x41, 0xf9 => 0x99, 0xfa => 0x2d, 0xfb => 0x0f, 0xfc => 0xb0, 0xfd => 0x54, 0xfe => 0xbb, 0xff => 0x16,
    }
}

/// Substitution box inverse
fn sbox_inv(byte: u8) -> u8 {
    match byte {
        // row 0
        0x63 => 0x00, 0x7c => 0x01, 0x77 => 0x02, 0x7b => 0x03, 0xf2 => 0x04, 0x6b => 0x05, 0x6f => 0x06, 0xc5 => 0x07,
        0x30 => 0x08, 0x01 => 0x09, 0x67 => 0x0a, 0x2b => 0x0b, 0xfe => 0x0c, 0xd7 => 0x0d, 0xab => 0x0e, 0x76 => 0x0f,
        // row 1
        0xca => 0x10, 0x82 => 0x11, 0xc9 => 0x12, 0x7d => 0x13, 0xfa => 0x14, 0x59 => 0x15, 0x47 => 0x16, 0xf0 => 0x17,
        0xad => 0x18, 0xd4 => 0x19, 0xa2 => 0x1a, 0xaf => 0x1b, 0x9c => 0x1c, 0xa4 => 0x1d, 0x72 => 0x1e, 0xc0 => 0x1f,
        // row 2
        0xb7 => 0x20, 0xfd => 0x21, 0x93 => 0x22, 0x26 => 0x23, 0x36 => 0x24, 0x3f => 0x25, 0xf7 => 0x26, 0xcc => 0x27,
        0x34 => 0x28, 0xa5 => 0x29, 0xe5 => 0x2a, 0xf1 => 0x2b, 0x71 => 0x2c, 0xd8 => 0x2d, 0x31 => 0x2e, 0x15 => 0x2f,
        // row 3
        0x04 => 0x30, 0xc7 => 0x31, 0x23 => 0x32, 0xc3 => 0x33, 0x18 => 0x34, 0x96 => 0x35, 0x05 => 0x36, 0x9a => 0x37,
        0x07 => 0x38, 0x12 => 0x39, 0x80 => 0x3a, 0xe2 => 0x3b, 0xeb => 0x3c, 0x27 => 0x3d, 0xb2 => 0x3e, 0x75 => 0x3f,
        // row 4
        0x09 => 0x40, 0x83 => 0x41, 0x2c => 0x42, 0x1a => 0x43, 0x1b => 0x44, 0x6e => 0x45, 0x5a => 0x46, 0xa0 => 0x47,
        0x52 => 0x48, 0x3b => 0x49, 0xd6 => 0x4a, 0xb3 => 0x4b, 0x29 => 0x4c, 0xe3 => 0x4d, 0x2f => 0x4e, 0x84 => 0x4f,
        // row 5
        0x53 => 0x50, 0xd1 => 0x51, 0x00 => 0x52, 0xed => 0x53, 0x20 => 0x54, 0xfc => 0x55, 0xb1 => 0x56, 0x5b => 0x57,
        0x6a => 0x58, 0xcb => 0x59, 0xbe => 0x5a, 0x39 => 0x5b, 0x4a => 0x5c, 0x4c => 0x5d, 0x58 => 0x5e, 0xcf => 0x5f,
        // row 6
        0xd0 => 0x60, 0xef => 0x61, 0xaa => 0x62, 0xfb => 0x63, 0x43 => 0x64, 0x4d => 0x65, 0x33 => 0x66, 0x85 => 0x67,
        0x45 => 0x68, 0xf9 => 0x69, 0x02 => 0x6a, 0x7f => 0x6b, 0x50 => 0x6c, 0x3c => 0x6d, 0x9f => 0x6e, 0xa8 => 0x6f,
        // row 7
        0x51 => 0x70, 0xa3 => 0x71, 0x40 => 0x72, 0x8f => 0x73, 0x92 => 0x74, 0x9d => 0x75, 0x38 => 0x76, 0xf5 => 0x77,
        0xbc => 0x78, 0xb6 => 0x79, 0xda => 0x7a, 0x21 => 0x7b, 0x10 => 0x7c, 0xff => 0x7d, 0xf3 => 0x7e, 0xd2 => 0x7f,
        // row 8
        0xcd => 0x80, 0x0c => 0x81, 0x13 => 0x82, 0xec => 0x83, 0x5f => 0x84, 0x97 => 0x85, 0x44 => 0x86, 0x17 => 0x87,
        0xc4 => 0x88, 0xa7 => 0x89, 0x7e => 0x8a, 0x3d => 0x8b, 0x64 => 0x8c, 0x5d => 0x8d, 0x19 => 0x8e, 0x73 => 0x8f,
        // row 9
        0x60 => 0x90, 0x81 => 0x91, 0x4f => 0x92, 0xdc => 0x93, 0x22 => 0x94, 0x2a => 0x95, 0x90 => 0x96, 0x88 => 0x97,
        0x46 => 0x98, 0xee => 0x99, 0xb8 => 0x9a, 0x14 => 0x9b, 0xde => 0x9c, 0x5e => 0x9d, 0x0b => 0x9e, 0xdb => 0x9f,
        // row a
        0xe0 => 0xa0, 0x32 => 0xa1, 0x3a => 0xa2, 0x0a => 0xa3, 0x49 => 0xa4, 0x06 => 0xa5, 0x24 => 0xa6, 0x5c => 0xa7,
        0xc2 => 0xa8, 0xd3 => 0xa9, 0xac => 0xaa, 0x62 => 0xab, 0x91 => 0xac, 0x95 => 0xad, 0xe4 => 0xae, 0x79 => 0xaf,
        // row b
        0xe7 => 0xb0, 0xc8 => 0xb1, 0x37 => 0xb2, 0x6d => 0xb3, 0x8d => 0xb4, 0xd5 => 0xb5, 0x4e => 0xb6, 0xa9 => 0xb7,
        0x6c => 0xb8, 0x56 => 0xb9, 0xf4 => 0xba, 0xea => 0xbb, 0x65 => 0xbc, 0x7a => 0xbd, 0xae => 0xbe, 0x08 => 0xbf,
        // row c
        0xba => 0xc0, 0x78 => 0xc1, 0x25 => 0xc2, 0x2e => 0xc3, 0x1c => 0xc4, 0xa6 => 0xc5, 0xb4 => 0xc6, 0xc6 => 0xc7,
        0xe8 => 0xc8, 0xdd => 0xc9, 0x74 => 0xca, 0x1f => 0xcb, 0x4b => 0xcc, 0xbd => 0xcd, 0x8b => 0xce, 0x8a => 0xcf,
        // row d
        0x70 => 0xd0, 0x3e => 0xd1, 0xb5 => 0xd2, 0x66 => 0xd3, 0x48 => 0xd4, 0x03 => 0xd5, 0xf6 => 0xd6, 0x0e => 0xd7,
        0x61 => 0xd8, 0x35 => 0xd9, 0x57 => 0xda, 0xb9 => 0xdb, 0x86 => 0xdc, 0xc1 => 0xdd, 0x1d => 0xde, 0x9e => 0xdf,
        // row e
        0xe1 => 0xe0, 0xf8 => 0xe1, 0x98 => 0xe2, 0x11 => 0xe3, 0x69 => 0xe4, 0xd9 => 0xe5, 0x8e => 0xe6, 0x94 => 0xe7,
        0x9b => 0xe8, 0x1e => 0xe9, 0x87 => 0xea, 0xe9 => 0xeb, 0xce => 0xec, 0x55 => 0xed, 0x28 => 0xee, 0xdf => 0xef,
        // row f
        0x8c => 0xf0, 0xa1 => 0xf1, 0x89 => 0xf2, 0x0d => 0xf3, 0xbf => 0xf4, 0xe6 => 0xf5, 0x42 => 0xf6, 0x68 => 0xf7,
        0x41 => 0xf8, 0x99 => 0xf9, 0x2d => 0xfa, 0x0f => 0xfb, 0xb0 => 0xfc, 0x54 => 0xfd, 0xbb => 0xfe, 0x16 => 0xff,
    }
}

// Apply S-Box to each word in the state
fn sub_bytes(state: &mut [u32; N_BLOCK]) {
    for word in state.iter_mut() {
        *word = sub_word(&word);
    }
}

// Apply inverse S-Box to each word in the state
fn inv_sub_bytes(state: &mut [u32; N_BLOCK]) {
    for word in state.iter_mut() {
        *word = inv_sub_word(&word);
    }
}

// Shift state words relative to row index
fn shift_rows(state: &mut [u32; N_BLOCK]) {
    let s0 = state[0].to_be_bytes();
    let s1 = state[1].to_be_bytes();
    let s2 = state[2].to_be_bytes();
    let s3 = state[3].to_be_bytes();

    state[0] = u32::from_be_bytes([s0[0], s1[1], s2[2], s3[3]]);
    state[1] = u32::from_be_bytes([s1[0], s2[1], s3[2], s0[3]]);
    state[2] = u32::from_be_bytes([s2[0], s3[1], s0[2], s1[3]]);
    state[3] = u32::from_be_bytes([s3[0], s0[1], s1[2], s2[3]]);
}

// Inverse shift state words relative to row index
fn inv_shift_rows(state: &mut [u32; N_BLOCK]) {
    let s0 = state[0].to_be_bytes();
    let s1 = state[1].to_be_bytes();
    let s2 = state[2].to_be_bytes();
    let s3 = state[3].to_be_bytes();

    state[0] = u32::from_be_bytes([s0[0], s3[1], s2[2], s1[3]]);
    state[1] = u32::from_be_bytes([s1[0], s0[1], s3[2], s2[3]]);
    state[2] = u32::from_be_bytes([s2[0], s1[1], s0[2], s3[3]]);
    state[3] = u32::from_be_bytes([s3[0], s2[1], s1[2], s0[3]]);
}

// Treat state words as columns in a matrix, perform the following matrix-vector multiplication:
//
// Example:
//
// s0' = 0x02*s0 + 0x03*s1 + s2 + s3
// s1' = s0 + 0x02*s1 + 0x03*s2 + s3
// s2' = s0 + s1 + 0x02*s2 + 0x03*s3
// s3' = 0x03*s0 + s1 + s2 + 0x02*s3
fn mix_columns(state: &mut [u32; N_BLOCK]) {
    state[0] = mix_word(state[0]);
    state[1] = mix_word(state[1]);
    state[2] = mix_word(state[2]);
    state[3] = mix_word(state[3]);
}

// Perform the inner multiplication for MixColumns
fn mix_word(word: u32) -> u32 {
    let s = word.to_be_bytes();

    let sp0 = xmul(0x2, s[0]) ^ xmul(0x3, s[1]) ^ s[2] ^ s[3];
    let sp1 = s[0] ^ xmul(0x2, s[1]) ^ xmul(0x3, s[2]) ^ s[3];
    let sp2 = s[0] ^ s[1] ^ xmul(0x2, s[2]) ^ xmul(0x3, s[3]);
    let sp3 = xmul(0x3, s[0]) ^ s[1] ^ s[2] ^ xmul(0x2, s[3]);

    u32::from_be_bytes([sp0, sp1, sp2, sp3])
}

// Perform InvMixColumns as matrix-vector multiplication
fn inv_mix_columns(state: &mut [u32; N_BLOCK]) {
    state[0] = inv_mix_word(state[0]);
    state[1] = inv_mix_word(state[1]);
    state[2] = inv_mix_word(state[2]);
    state[3] = inv_mix_word(state[3]);
}

// Perform the inner inverse multiplication for InvMixColumns
fn inv_mix_word(word: u32) -> u32 {
    let s = word.to_be_bytes();

    let sp0 = xmul(0xe, s[0]) ^ xmul(0xb, s[1]) ^ xmul(0xd, s[2]) ^ xmul(0x9, s[3]);
    let sp1 = xmul(0x9, s[0]) ^ xmul(0xe, s[1]) ^ xmul(0xb, s[2]) ^ xmul(0xd, s[3]);
    let sp2 = xmul(0xd, s[0]) ^ xmul(0x9, s[1]) ^ xmul(0xe, s[2]) ^ xmul(0xb, s[3]);
    let sp3 = xmul(0xb, s[0]) ^ xmul(0xd, s[1]) ^ xmul(0x9, s[2]) ^ xmul(0xe, s[3]);

    u32::from_be_bytes([sp0, sp1, sp2, sp3])
}

// Multiply a byte by a constant
fn xmul(b: u8, c: u8) -> u8 {
    // keep intermediate calculations of xtime(b1)..xtime(b8)
    let b2 = xtime(b);
    let b3 = xtime(b2);
    let b4 = xtime(b3);
    let b5 = xtime(b4);
    let b6 = xtime(b5);
    let b7 = xtime(b6);
    let b8 = xtime(b7);

    // multiply intermediate results by 1 if the bit
    // is set in the constant, zero otherwise
    // i.e. sum ^= if cn { bn } else { 0 }
    (b * (c & 0x1))
        ^ (b2 * ((c & 0x2) >> 1))
        ^ (b3 * ((c & 0x4) >> 2))
        ^ (b4 * ((c & 0x8) >> 3))
        ^ (b5 * ((c & 0x10) >> 4))
        ^ (b6 * ((c & 0x20) >> 5))
        ^ (b7 * ((c & 0x40) >> 6))
        ^ (b8 * ((c & 0x80) >> 7))
}

// Multiply a byte by two, and apply conditional XOR to reduce
// to a number mod 255
fn xtime(b: u8) -> u8 {
    let res = (b as u16) << 1;
    let is_red = b & 0b1000_0000 == 0;

    // if is_red { res } else { res ^ 0x1b }
    // de-sugared for constant-time evaluation
    ((is_red as u16 * res) + (!is_red as u16 * (res ^ 0x1b))) as u8
}

// Add round key words to state words using XOR
fn add_round_key(state: &mut [u32; 4], round_key: &[u32]) {
    for (state_word, key_word) in state.iter_mut().zip(round_key.iter()) {
        *state_word ^= *key_word;
    }
}

// Nb = 4
// Nk = 4
// Nr = 10
//
// KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
// begin
//   word  tempi = 0
//   while (i < Nk)
//     w[i] = word(key[4*i], key[4*i+1], key[4*i+2], key[4*i+3])
//     i = i+1
//   end while
//   i = Nk
//   while (i < Nb * (Nr+1))
//     temp = w[i-1]
//     if (i mod Nk = 0)
//       temp = SubWord(RotWord(temp)) xor Rcon[i/Nk]
//     else if (Nk > 6 and i mod Nk = 4)
//       temp = SubWord(temp)
//     end if
//     w[i] = w[i-Nk] xor temp
//     i = i + 1
//   end while
// end
fn expand_key_128(key: &[u8; KEY_LEN_128]) -> [u32; N_EXPW_128] {
    let mut out = [0_u32; N_EXPW_128];
    for i in 0..N_KEY_128 {
        let base = i*4;
        out[i] = ((key[base] as u32) << 24)
            + ((key[base + 1] as u32) << 16)
            + ((key[base + 2] as u32) << 8)
            + (key[base + 3] as u32);
    }
    for i in N_KEY_128..N_EXPW_128 {
        let mut temp = out[i - 1];
        let k_round = (i % N_KEY_128 == 0) as u32;
        // calculate k-round transform every round for constant-time execution
        let xform_temp = sub_word(&rot_word(&temp, 1)) ^ round_const(i / N_KEY_128);
        // evaluates to temp for non-k-round, and transform(temp) for k-round
        // Note: AES-256 requires evaluating a third branch for mod-4 rounds
        temp = (temp * (k_round ^ 0x0000_0001)) + (xform_temp * k_round);
        out[i] = out[i - N_KEY_128] ^ temp;
    }
    out
}

// Apply SBOX substitution on the state word as bytes
fn sub_word(word: &u32) -> u32 {
    u32::from_be_bytes([
                       sbox(((*word & 0xff00_0000) >> 24) as u8),
                       sbox(((*word & 0xff_0000) >> 16) as u8),
                       sbox(((*word & 0xff00) >> 8) as u8),
                       sbox((*word & 0xff) as u8),
    ])
}

fn inv_sub_word(word: &u32) -> u32 {
    u32::from_be_bytes([
                       sbox_inv(((*word & 0xff00_0000) >> 24) as u8),
                       sbox_inv(((*word & 0xff_0000) >> 16) as u8),
                       sbox_inv(((*word & 0xff00) >> 8) as u8),
                       sbox_inv((*word & 0xff) as u8),
    ])
}

// Perform a cyclic rotation on 32-bit word
fn rot_word(word: &u32, cycle: u32) -> u32 {
    let blk32 = N_BLOCK as u32;

    if cycle >= blk32 {
        panic!("invalid cycle rotation for {}-bit word", blk32 * 8);
    }

    (word << (cycle * 8)) + (word >> ((blk32 - cycle) * 8))
}

// Round constant: 2^(i-1) % 2^8
fn round_const(round: usize) -> u32 {
    match round {
        1 => 0x01000000,
        2 => 0x02000000,
        3 => 0x04000000,
        4 => 0x08000000,
        5 => 0x10000000,
        6 => 0x20000000,
        7 => 0x40000000,
        8 => 0x80000000,
        9 => 0x1b000000,
        10 => 0x36000000,
        _ => panic!("invalid round number"),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_xtime() {
        assert_eq!(xtime(0x57), 0xae);
        assert_eq!(xtime(0xae), 0x47);
        assert_eq!(xtime(0x47), 0x8e);
        assert_eq!(xtime(0x8e), 0x07);
    }

    #[test]
    fn check_xmul() {
        assert_eq!(xmul(0x57, 0x13), 0xfe);
        assert_eq!(xmul(0x57, 0x83), 0xc1);
    }

    #[test]
    fn check_rot_word() {
        assert_eq!(rot_word(&0x09cf4f3c, 1), 0xcf4f3c09);
    }

    #[test]
    fn check_sub_word() {
        assert_eq!(sub_word(&0xcf4f3c09), 0x8a84eb01);
    }

    #[test]
    fn check_sub_bytes() {
        let mut state = [0xcf4f3c09, 0x6c76052a, 0x59f67f73, 0x7a883b6d];
        let exp_out = [0x8a84eb01, 0x50386be5, 0xcb42d28f, 0xdac4e23c];

        sub_bytes(&mut state);

        assert_eq!(state, exp_out);
    }

    #[test]
    fn check_inv_sub_word() {
        assert_eq!(inv_sub_word(&sub_word(&0xcf4f3c09)), 0xcf4f3c09);
    }

    #[test]
    fn check_inv_sub_bytes() {
        let mut state = [0xcf4f3c09, 0x6c76052a, 0x59f67f73, 0x7a883b6d];
        let orig = state.clone();

        sub_bytes(&mut state);
        inv_sub_bytes(&mut state);

        assert_eq!(state, orig);
    }

    #[test]
    fn check_rcon() {
        assert_eq!(round_const(4 / N_KEY_128), 0x01000000);
        assert_eq!(round_const(8 / N_KEY_128), 0x02000000);
        assert_eq!(round_const(12 / N_KEY_128), 0x04000000);
        assert_eq!(round_const(16 / N_KEY_128), 0x08000000);
        assert_eq!(round_const(20 / N_KEY_128), 0x10000000);
        assert_eq!(round_const(24 / N_KEY_128), 0x20000000);
        assert_eq!(round_const(28 / N_KEY_128), 0x40000000);
        assert_eq!(round_const(32 / N_KEY_128), 0x80000000);
        assert_eq!(round_const(36 / N_KEY_128), 0x1b000000);
        assert_eq!(round_const(40 / N_KEY_128), 0x36000000);
    }

    #[test]
    fn check_mix_columns() {
        let mut inp = [0xd4bf5d30, 0xe0b452ae, 0xb84111f1, 0x1e2798e5];
        mix_columns(&mut inp);

        assert_eq!(inp, [0x046681e5, 0xe0cb199a, 0x48f8d37a, 0x2806264c]);
    }

    #[test]
    fn check_inv_mix_columns() {
        let mut inp = [0xd4bf5d30, 0xe0b452ae, 0xb84111f1, 0x1e2798e5];
        let orig = inp.clone();

        mix_columns(&mut inp);
        inv_mix_columns(&mut inp);

        assert_eq!(inp, orig);
    }

    #[test]
    fn check_shift_rows() {
        let mut inp = [0xd42711ae, 0xe0bf98f1, 0xb8b45de5, 0x1e415230];
        shift_rows(&mut inp);

        assert_eq!(inp, [0xd4bf5d30, 0xe0b452ae, 0xb84111f1, 0x1e2798e5]);
    }

    #[test]
    fn check_inv_shift_rows() {
        let mut inp = [0xd42711ae, 0xe0bf98f1, 0xb8b45de5, 0x1e415230];
        let orig = inp.clone();

        shift_rows(&mut inp);
        inv_shift_rows(&mut inp);

        assert_eq!(inp, orig);
    }

    #[test]
    fn check_key_expand() {
        let key: [u8; KEY_LEN_128] = [0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c];
        let exp_out: [u32; N_EXPW_128] = [
            0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c,
            0xa0fafe17, 0x88542cb1, 0x23a33939, 0x2a6c7605,
            0xf2c295f2, 0x7a96b943, 0x5935807a, 0x7359f67f,
            0x3d80477d, 0x4716fe3e, 0x1e237e44, 0x6d7a883b,
            0xef44a541, 0xa8525b7f, 0xb671253b, 0xdb0bad00,
            0xd4d1c6f8, 0x7c839d87, 0xcaf2b8bc, 0x11f915bc,
            0x6d88a37a, 0x110b3efd, 0xdbf98641, 0xca0093fd,
            0x4e54f70e, 0x5f5fc9f3, 0x84a64fb2, 0x4ea6dc4f,
            0xead27321, 0xb58dbad2, 0x312bf560, 0x7f8d292f,
            0xac7766f3, 0x19fadc21, 0x28d12941, 0x575c006e,
            0xd014f9a8, 0xc9ee2589, 0xe13f0cc8, 0xb6630ca6,
        ];

        assert_eq!(expand_key_128(&key), exp_out);
    }

    #[test]
    fn check_aes_128() {
        let msg: [u8; BLOCK_LEN] = [0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34,];
        let key: [u8; KEY_LEN_128] = [0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,];
        let exp_out: [u8; BLOCK_LEN] = [
            0x39, 0x25, 0x84, 0x1d, /*s0*/
            0x02, 0xdc, 0x09, 0xfb, /*s1*/
            0xdc, 0x11, 0x85, 0x97, /*s2*/
            0x19, 0x6a, 0x0b, 0x32, /*s3*/
        ];

        assert_eq!(aes_128(&msg, &key), exp_out);
    }

    #[test]
    fn check_aes_inv_128() {
        let msg: [u8; BLOCK_LEN] = [0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34,];
        let key: [u8; KEY_LEN_128] = [0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,];
        let exp_out: [u8; BLOCK_LEN] = [
            0x39, 0x25, 0x84, 0x1d, /*s0*/
            0x02, 0xdc, 0x09, 0xfb, /*s1*/
            0xdc, 0x11, 0x85, 0x97, /*s2*/
            0x19, 0x6a, 0x0b, 0x32, /*s3*/
        ];

        assert_eq!(aes_128(&msg, &key), exp_out);
        assert_eq!(aes_inv_128(&exp_out, &key), msg);
    }

    #[test]
    fn check_sboxes() {
        for byte in 0x00_u8..=0xff_u8 {
            assert_eq!(sbox_inv(sbox(byte)), byte);
        }

        //         //  0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f
        // /* 0 */ [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
        assert_eq!(sbox(0x00), 0x63); assert_eq!(sbox(0x01), 0x7c); assert_eq!(sbox(0x02), 0x77); assert_eq!(sbox(0x03), 0x7b);
        assert_eq!(sbox(0x04), 0xf2); assert_eq!(sbox(0x05), 0x6b); assert_eq!(sbox(0x06), 0x6f); assert_eq!(sbox(0x07), 0xc5);
        assert_eq!(sbox(0x08), 0x30); assert_eq!(sbox(0x09), 0x01); assert_eq!(sbox(0x0a), 0x67); assert_eq!(sbox(0x0b), 0x2b);
        assert_eq!(sbox(0x0c), 0xfe); assert_eq!(sbox(0x0d), 0xd7); assert_eq!(sbox(0x0e), 0xab); assert_eq!(sbox(0x0f), 0x76);

        // /* 1 */ [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
        assert_eq!(sbox(0x10), 0xca); assert_eq!(sbox(0x11), 0x82); assert_eq!(sbox(0x12), 0xc9); assert_eq!(sbox(0x13), 0x7d);
        assert_eq!(sbox(0x14), 0xfa); assert_eq!(sbox(0x15), 0x59); assert_eq!(sbox(0x16), 0x47); assert_eq!(sbox(0x17), 0xf0);
        assert_eq!(sbox(0x18), 0xad); assert_eq!(sbox(0x19), 0xd4); assert_eq!(sbox(0x1a), 0xa2); assert_eq!(sbox(0x1b), 0xaf);
        assert_eq!(sbox(0x1c), 0x9c); assert_eq!(sbox(0x1d), 0xa4); assert_eq!(sbox(0x1e), 0x72); assert_eq!(sbox(0x1f), 0xc0);

        // /* 2 */ [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
        assert_eq!(sbox(0x20), 0xb7); assert_eq!(sbox(0x21), 0xfd); assert_eq!(sbox(0x22), 0x93); assert_eq!(sbox(0x23), 0x26);
        assert_eq!(sbox(0x24), 0x36); assert_eq!(sbox(0x25), 0x3f); assert_eq!(sbox(0x26), 0xf7); assert_eq!(sbox(0x27), 0xcc);
        assert_eq!(sbox(0x28), 0x34); assert_eq!(sbox(0x29), 0xa5); assert_eq!(sbox(0x2a), 0xe5); assert_eq!(sbox(0x2b), 0xf1);
        assert_eq!(sbox(0x2c), 0x71); assert_eq!(sbox(0x2d), 0xd8); assert_eq!(sbox(0x2e), 0x31); assert_eq!(sbox(0x2f), 0x15);

        // /* 3 */ [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
        assert_eq!(sbox(0x30), 0x04); assert_eq!(sbox(0x31), 0xc7); assert_eq!(sbox(0x32), 0x23); assert_eq!(sbox(0x33), 0xc3);
        assert_eq!(sbox(0x34), 0x18); assert_eq!(sbox(0x35), 0x96); assert_eq!(sbox(0x36), 0x05); assert_eq!(sbox(0x37), 0x9a);
        assert_eq!(sbox(0x38), 0x07); assert_eq!(sbox(0x39), 0x12); assert_eq!(sbox(0x3a), 0x80); assert_eq!(sbox(0x3b), 0xe2);
        assert_eq!(sbox(0x3c), 0xeb); assert_eq!(sbox(0x3d), 0x27); assert_eq!(sbox(0x3e), 0xb2); assert_eq!(sbox(0x3f), 0x75);

        // /* 4 */ [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
        assert_eq!(sbox(0x40), 0x09); assert_eq!(sbox(0x41), 0x83); assert_eq!(sbox(0x42), 0x2c); assert_eq!(sbox(0x43), 0x1a);
        assert_eq!(sbox(0x44), 0x1b); assert_eq!(sbox(0x45), 0x6e); assert_eq!(sbox(0x46), 0x5a); assert_eq!(sbox(0x47), 0xa0);
        assert_eq!(sbox(0x48), 0x52); assert_eq!(sbox(0x49), 0x3b); assert_eq!(sbox(0x4a), 0xd6); assert_eq!(sbox(0x4b), 0xb3);
        assert_eq!(sbox(0x4c), 0x29); assert_eq!(sbox(0x4d), 0xe3); assert_eq!(sbox(0x4e), 0x2f); assert_eq!(sbox(0x4f), 0x84);

        // /* 5 */ [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
        assert_eq!(sbox(0x50), 0x53); assert_eq!(sbox(0x51), 0xd1); assert_eq!(sbox(0x52), 0x00); assert_eq!(sbox(0x53), 0xed);
        assert_eq!(sbox(0x54), 0x20); assert_eq!(sbox(0x55), 0xfc); assert_eq!(sbox(0x56), 0xb1); assert_eq!(sbox(0x57), 0x5b);
        assert_eq!(sbox(0x58), 0x6a); assert_eq!(sbox(0x59), 0xcb); assert_eq!(sbox(0x5a), 0xbe); assert_eq!(sbox(0x5b), 0x39);
        assert_eq!(sbox(0x5c), 0x4a); assert_eq!(sbox(0x5d), 0x4c); assert_eq!(sbox(0x5e), 0x58); assert_eq!(sbox(0x5f), 0xcf);

        // /* 6 */ [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
        assert_eq!(sbox(0x60), 0xd0); assert_eq!(sbox(0x61), 0xef); assert_eq!(sbox(0x62), 0xaa); assert_eq!(sbox(0x63), 0xfb);
        assert_eq!(sbox(0x64), 0x43); assert_eq!(sbox(0x65), 0x4d); assert_eq!(sbox(0x66), 0x33); assert_eq!(sbox(0x67), 0x85);
        assert_eq!(sbox(0x68), 0x45); assert_eq!(sbox(0x69), 0xf9); assert_eq!(sbox(0x6a), 0x02); assert_eq!(sbox(0x6b), 0x7f);
        assert_eq!(sbox(0x6c), 0x50); assert_eq!(sbox(0x6d), 0x3c); assert_eq!(sbox(0x6e), 0x9f); assert_eq!(sbox(0x6f), 0xa8);

        // /* 7 */ [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
        assert_eq!(sbox(0x70), 0x51); assert_eq!(sbox(0x71), 0xa3); assert_eq!(sbox(0x72), 0x40); assert_eq!(sbox(0x73), 0x8f);
        assert_eq!(sbox(0x74), 0x92); assert_eq!(sbox(0x75), 0x9d); assert_eq!(sbox(0x76), 0x38); assert_eq!(sbox(0x77), 0xf5);
        assert_eq!(sbox(0x78), 0xbc); assert_eq!(sbox(0x79), 0xb6); assert_eq!(sbox(0x7a), 0xda); assert_eq!(sbox(0x7b), 0x21);
        assert_eq!(sbox(0x7c), 0x10); assert_eq!(sbox(0x7d), 0xff); assert_eq!(sbox(0x7e), 0xf3); assert_eq!(sbox(0x7f), 0xd2);

        // /* 8 */ [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
        assert_eq!(sbox(0x80), 0xcd); assert_eq!(sbox(0x81), 0x0c); assert_eq!(sbox(0x82), 0x13); assert_eq!(sbox(0x83), 0xec);
        assert_eq!(sbox(0x84), 0x5f); assert_eq!(sbox(0x85), 0x97); assert_eq!(sbox(0x86), 0x44); assert_eq!(sbox(0x87), 0x17);
        assert_eq!(sbox(0x88), 0xc4); assert_eq!(sbox(0x89), 0xa7); assert_eq!(sbox(0x8a), 0x7e); assert_eq!(sbox(0x8b), 0x3d);
        assert_eq!(sbox(0x8c), 0x64); assert_eq!(sbox(0x8d), 0x5d); assert_eq!(sbox(0x8e), 0x19); assert_eq!(sbox(0x8f), 0x73);

        // /* 9 */ [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
        assert_eq!(sbox(0x90), 0x60); assert_eq!(sbox(0x91), 0x81); assert_eq!(sbox(0x92), 0x4f); assert_eq!(sbox(0x93), 0xdc);
        assert_eq!(sbox(0x94), 0x22); assert_eq!(sbox(0x95), 0x2a); assert_eq!(sbox(0x96), 0x90); assert_eq!(sbox(0x97), 0x88);
        assert_eq!(sbox(0x98), 0x46); assert_eq!(sbox(0x99), 0xee); assert_eq!(sbox(0x9a), 0xb8); assert_eq!(sbox(0x9b), 0x14);
        assert_eq!(sbox(0x9c), 0xde); assert_eq!(sbox(0x9d), 0x5e); assert_eq!(sbox(0x9e), 0x0b); assert_eq!(sbox(0x9f), 0xdb);

        // /* a */ [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
        assert_eq!(sbox(0xa0), 0xe0); assert_eq!(sbox(0xa1), 0x32); assert_eq!(sbox(0xa2), 0x3a); assert_eq!(sbox(0xa3), 0x0a);
        assert_eq!(sbox(0xa4), 0x49); assert_eq!(sbox(0xa5), 0x06); assert_eq!(sbox(0xa6), 0x24); assert_eq!(sbox(0xa7), 0x5c);
        assert_eq!(sbox(0xa8), 0xc2); assert_eq!(sbox(0xa9), 0xd3); assert_eq!(sbox(0xaa), 0xac); assert_eq!(sbox(0xab), 0x62);
        assert_eq!(sbox(0xac), 0x91); assert_eq!(sbox(0xad), 0x95); assert_eq!(sbox(0xae), 0xe4); assert_eq!(sbox(0xaf), 0x79);

        // /* b */ [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
        assert_eq!(sbox(0xb0), 0xe7); assert_eq!(sbox(0xb1), 0xc8); assert_eq!(sbox(0xb2), 0x37); assert_eq!(sbox(0xb3), 0x6d);
        assert_eq!(sbox(0xb4), 0x8d); assert_eq!(sbox(0xb5), 0xd5); assert_eq!(sbox(0xb6), 0x4e); assert_eq!(sbox(0xb7), 0xa9);
        assert_eq!(sbox(0xb8), 0x6c); assert_eq!(sbox(0xb9), 0x56); assert_eq!(sbox(0xba), 0xf4); assert_eq!(sbox(0xbb), 0xea);
        assert_eq!(sbox(0xbc), 0x65); assert_eq!(sbox(0xbd), 0x7a); assert_eq!(sbox(0xbe), 0xae); assert_eq!(sbox(0xbf), 0x08);

        // /* c */ [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
        assert_eq!(sbox(0xc0), 0xba); assert_eq!(sbox(0xc1), 0x78); assert_eq!(sbox(0xc2), 0x25); assert_eq!(sbox(0xc3), 0x2e);
        assert_eq!(sbox(0xc4), 0x1c); assert_eq!(sbox(0xc5), 0xa6); assert_eq!(sbox(0xc6), 0xb4); assert_eq!(sbox(0xc7), 0xc6);
        assert_eq!(sbox(0xc8), 0xe8); assert_eq!(sbox(0xc9), 0xdd); assert_eq!(sbox(0xca), 0x74); assert_eq!(sbox(0xcb), 0x1f);
        assert_eq!(sbox(0xcc), 0x4b); assert_eq!(sbox(0xcd), 0xbd); assert_eq!(sbox(0xce), 0x8b); assert_eq!(sbox(0xcf), 0x8a);

        // /* d */ [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
        assert_eq!(sbox(0xd0), 0x70); assert_eq!(sbox(0xd1), 0x3e); assert_eq!(sbox(0xd2), 0xb5); assert_eq!(sbox(0xd3), 0x66);
        assert_eq!(sbox(0xd4), 0x48); assert_eq!(sbox(0xd5), 0x03); assert_eq!(sbox(0xd6), 0xf6); assert_eq!(sbox(0xd7), 0x0e);
        assert_eq!(sbox(0xd8), 0x61); assert_eq!(sbox(0xd9), 0x35); assert_eq!(sbox(0xda), 0x57); assert_eq!(sbox(0xdb), 0xb9);
        assert_eq!(sbox(0xdc), 0x86); assert_eq!(sbox(0xdd), 0xc1); assert_eq!(sbox(0xde), 0x1d); assert_eq!(sbox(0xdf), 0x9e);

        // /* e */ [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
        assert_eq!(sbox(0xe0), 0xe1); assert_eq!(sbox(0xe1), 0xf8); assert_eq!(sbox(0xe2), 0x98); assert_eq!(sbox(0xe3), 0x11);
        assert_eq!(sbox(0xe4), 0x69); assert_eq!(sbox(0xe5), 0xd9); assert_eq!(sbox(0xe6), 0x8e); assert_eq!(sbox(0xe7), 0x94);
        assert_eq!(sbox(0xe8), 0x9b); assert_eq!(sbox(0xe9), 0x1e); assert_eq!(sbox(0xea), 0x87); assert_eq!(sbox(0xeb), 0xe9);
        assert_eq!(sbox(0xec), 0xce); assert_eq!(sbox(0xed), 0x55); assert_eq!(sbox(0xee), 0x28); assert_eq!(sbox(0xef), 0xdf);

        // /* f */ [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16],
        assert_eq!(sbox(0xf0), 0x8c); assert_eq!(sbox(0xf1), 0xa1); assert_eq!(sbox(0xf2), 0x89); assert_eq!(sbox(0xf3), 0x0d);
        assert_eq!(sbox(0xf4), 0xbf); assert_eq!(sbox(0xf5), 0xe6); assert_eq!(sbox(0xf6), 0x42); assert_eq!(sbox(0xf7), 0x68);
        assert_eq!(sbox(0xf8), 0x41); assert_eq!(sbox(0xf9), 0x99); assert_eq!(sbox(0xfa), 0x2d); assert_eq!(sbox(0xfb), 0x0f);
        assert_eq!(sbox(0xfc), 0xb0); assert_eq!(sbox(0xfd), 0x54); assert_eq!(sbox(0xfe), 0xbb); assert_eq!(sbox(0xff), 0x16);
    }
}
